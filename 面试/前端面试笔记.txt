1、在Vue中使用插件的步骤
采用ES6的import ... from ...语法或CommonJS的require()方法引入插件。
使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })。
2，前端设置浏览器缓存
       通过HTTP的META设置expires和cache-control(常用，更有效）
       <meta http-equiv="Cache-Control" content=“max-age=7200”/>(常用，更有效）
       <meta http-equiv="Expires" content=“Sun Oct 15 2017 20:39:53 GMT+0800(CST)”/>
3，vue项目实现路由按需加载(路由懒加载)的3种方式
     1，vue异步组件
     2，es提案的import()
     3，webpack的require,ensure()
4，为什么需要懒加载？
　　像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时
5.http（2,0）和https
  HTTP2.0：
    内容安全：http2.0是基于https的
    二进制分帧：http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对      他们采用二进制格式编码。改进了传输的性能。
    多路复用：
       相当于长连接的增强。
       所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。
       每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个       帧头部的流标识符（stream id）重新组装。
    头部压缩
    服务器推送
6.闭包
7.内存泄漏:
  不再用到的内存，没有及时释放，就叫做内存泄漏。
8.js垃圾回收机制
    1，解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。
    2，现在各大浏览器通常采用的垃圾回收机制有两种方法：标记清除，引用计数。
    标记清除：
          js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为"进入环境"，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为"离开环境"。
          垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。
          到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。
    引用计数：
          语言引擎有一张"引用表"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
9.vue(3.0)Proxy
10.虚拟dom
  它是一个object对象模型 用来模拟真实的dom
  作用是高效的渲染页面 减少不必要的dom操作 提高渲染效率
  DOM操作是昂贵的。
  步骤一：用JS对象模拟DOM树
  步骤二：比较两棵虚拟DOM树的差异
  步骤三：把差异应用到真正的DOM树上
11.diff算法
  diff算法就是用JavaScript来表示一个dom树的结构
  然后用这个dom去构建一个真实的dom 插入到文档中
  当状态变更的时候 重新构造一个dom树 比较新旧dom树 记录两个dom树的差异 并且通知视图开始更新
  diff算法就 用来比较vdom结构的
12.设计模式
  1.单例模式
    当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场
    场景：登录框。vuex 中的store
  2.观察者模式
    当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。
    场景：DOM事件；vue 响应式
  3.策略模式
    对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。把它们一个个封装起来，并且使它们可以互相替换.
    场景例子: 如果在一个系统里面有许多类，它们之间的区别仅在于它们的'行为'，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。一个系统需要动态地在几种算法中选择一种。表单验证
13.vue路由hash模式和history模式
  hash模式:
  1.
hash 模式的路由中带有 # 号

  2.hash 模式通过 window.onhashchange 方法监听路由的修改

  3.hash 模式在页面刷新的时候，发送的请求 url 是不带 # 后面的内容的
  4.hash 模式可以兼容部分低版本的浏览器

  5.hash 模式打包后，直接在浏览器中打开 /dist/index.html 可以正常的访问（原因是第 3 条指出的原因）
  history模式:
  1.history 模式是使用正常的 url 路径显示

  2.history 模式通过 pushState 和 replaceState 方式修改路由改变

  3.history 模式在页面刷新的时候，会请求当前地址栏中完成的 url，这时需要服务器对这个 url 有    处理，如果没有对应的文件，需要返回 index.html

  4.history 模式因为是使用的 HTML5 的新规范，所以不能兼容低版本的浏览器

  5.history 模式打包后，直接在浏览器中打开 /dist/index.html 会报错（原因是第 3 条指出的原因）
  其他注意事向:
    有些 App 的分享是不支持 # 的，所以不能使用 hash 模式
14，this指向
   this是JavaScript中的一个关键字,this会在执行上下文中绑定一个对象，在不同的执行条件下会绑定不同的对象.
   1.函数在调用时，JavaScript会默认给this绑定一个值；
   2.this的绑定和定义的位置(编写的位置)没有关系；
   3.this的绑定和调用方式以及调用的位置有关系；
   4.this是在运行时被绑定的；
   this绑定规则：
   一，默认绑定
     1.独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；
        函数中的this指向全局对象(window)；
   二，隐式绑定
     1.函数是通过某个对象进行调用的；
        函数调用时this会隐式的被绑定到obj对象上
     隐式绑定有前提条件：
     1.必须在调用的对象内部有一个对函数的引用(比如一个属性)；
     2.如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
     3.正是通过这个引用，间接的将this绑定到了这个对象上；
   三，显示绑定
     1.通过call或者apply绑定this对象
	显示绑定后，this就会明确的指向绑定的对象
        JavaScript所有的函数都可以使用call和apply方法(这个和Prototype有关)。
	在调用这个函数时，会将this绑定到这个传入的对象上。
	因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 显示绑定。
   四，new绑定
     1.JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。
        this指向new出来的实例对象。
   五，规则优先级
	1.默认规则的优先级最低
	2.显示绑定优先级高于隐式绑定
	3.new绑定优先级高于隐式绑定
	4.new绑定优先级高于bind
	    new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高
15.适配不同屏幕
    Rem适配方案是当下流行并且兼容性最好的移动端适配解决方案，它支持大部分的移动端系统和机型，动态设置根元素font-size：采用媒体查询（Media Query）。
    Bootstrap
16.doctype
17.强制缓存和协商缓存
18.css /deep/ 深度选择器
19.什么时候用vuex
   1、当一个组件需要多次派发事件时
   2、跨组件共享数据、跨页面共享数据
20.es6
  1、es5和es6的区别：

　　ECMAScript5，即ES5，是ECMAScript的第五次修订，于2009年完成标准化

　　ECMAScript6，即ES6，是ECMAScript的第六次修订，于2015年完成，也称ES2015

　　ES6是继ES5之后的一次改进，相对于ES5更加简洁，提高了开发效率

　　ES6新增的一些特性：

　　1）let声明变量和const声明常量，两个都有块级作用域
　　ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明

　　2）箭头函数
　　ES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义

　　3）模板字符串
　　模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串

　　4）解构赋值
　　ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值

　　5）for of循环
　　for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串

　　6）import、export导入导出
　　ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用

　　7）set数据结构
　　Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数

　　8）... 展开运算符
　　可以将数组或对象里面的值展开；还可以将多个值收集为一个变量

　　9）修饰器 @
　　decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数

　　10）class 类的继承
　　ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念

　　11）async、await
　　使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性
　　async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成

　　12）promise
　　Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大

　　13）Symbol
　　Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的

　　14）Proxy代理
　　使用代理（Proxy）监听对象的操作，然后可以做一些相应事情
21.Set，Map
22.promise()一次请求成功就返回
       Promise.race（）
23.JS运行机制和事件循环
   javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。
     js运行机制：
   （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
   （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务     队列"之中放置一个事件。
   （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。    那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
   （4）主线程不断重复上面的第三步。
      事件循环：
    主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
24.技术点
25.首页白屏优化
   1、css文件加载需要一些时间，在加载的过程中页面是空白的。 解决：可以考虑将css代码前置和内联。
   2、首屏无实际的数据内容，等待异步加载数据再渲染页面导致白屏。 解决：在首屏直接同步渲染html，后续的滚屏等再采用异步请求数据和渲染html。
   3、首屏内联js的执行会阻塞页面的渲染。 解决：尽量不在首屏html代码中放置内联脚本。（来自翔歌）
   根本原因是客户端渲染的无力，因此最简单的方法是在服务器端，使用模板引擎渲染所有页面。同时
   1，减少文件加载体积，如html压缩，js压缩
   2，加快js执行速度 比如常见的无限滚动的页面，可以使用js先渲染一个屏幕范围内的东西
   3，提供一些友好的交互，比如提供一些假的滚动条
   4，使用本地存储处理静态文件。
26.link和@import 引入css的区别
    区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 
　　区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 
　　区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 
　　区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。 
27.浏览器的两个页面之间通信：
    1.localStorage        注：   两个页面要同源（URL的协议、域名和端口相同）
     一个窗口更新localStorage，
     另一个窗口监听window对象的”storage”事件，来实现通信。  
     // 本窗口的设值代码
     localStorage.setItem('aaa', (Math.random()*10).toString())
     // 其他窗口监听storage事件
     window.addEventListener("storage", function (e) {
       console.log(e)
       console.log(e.newValue)
     })
    2.WebSocket
      每个页面开启同一个地址的WebSocket服务，利用send发送消息，利用onmessage获取消息的变化。
      优点:
      不仅能在不同窗口之间，还能跨浏览器，兼容性最佳。
      缺点:
      需要消耗点服务器资源
        var ws = new WebSocket("ws://localhost:3000/")
        ws.onopen = function (event) {
        // 或者把此方法注册到其他事件中，即可与其他服务器通信
        ws.send({now : Date.now()}); // 通过服务器中转消息
        };
        ws.onmessage = function (event) {
        // 消费消息
        console.log(event.data);
        }
28.WebSocket(? )
    websocket 是一种网络通信协议，是HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议，这个对比着 http 协议来说，http 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。http 协议无法实现服务器主动向客户端发起消息，Websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。
29.浏览器输入Url
    1.浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
    2.DNS解析URL对应的IP。
    3.根据IP建立TCP连接（三次握手）。
    4.HTTP发起请求。
    5.服务器处理请求，浏览器接收HTTP响应。
    6.渲染页面，构建DOM树。
    7.关闭TCP连接（四次挥手）。
30.script 标签  异步
    1.defer
    2.async
31.H5,C3新特性
    H5：
   1、语义化标签：header、footer、nav、section、article、aside
   2、表单输入类型：email、tel、url、number
   3、表单属性：autocomplete、placeholder、form
   4、视频音频：audio、video
   5、拖拽属性：draggable
   6、类名操作：classlist
   7、web储存：
   cookie的大小不超过4kb，且每次请求都会发送回服务器，在设置的过期时间前有效，即使关闭浏览器
   h5提供：
   localStorage：数据始终有效，直到手动去删除。跨浏览器无效，浏览器提供的本地数据库，至少250kb，甚至没有上限
   localStorage.setItem(key,value)
   locatStorage.getItem(key)
   localStorage.removeItem(key)
   sessionStorage：基于会话，关闭浏览器之后数据消失，5M大小，跨浏览器无效
   C3：
   1、选择器：nth-child（）、nth-of-type（）、：checked、：disabled
   2、盒模型：
   3、背景：background-image、background-size、background-origin
   4、渐变：linear-gradient、radial-gradient
   5、边框：border-radius、border-image
   6、阴影：box-shadow、text-shadow
   7、2D/3D转换：transform：translate rotate scale
   8、过渡：transition
   9、动画：keyframes、animation
   10：弹性盒子：flex
   11：媒体查询：@media

32.webpack的打包流程
Webpack的打包流程包括以下几个步骤：
配置：首先，我们需要为Webpack创建一个配置文件，通常是一个名为webpack.config.js的文件。在配置文件中，我们指定入口文件（entry）和输出文件（output），以及其他模块加载器（loaders）和插件（plugins）等。
解析依赖：Webpack从入口文件开始，递归地解析所有的依赖关系。当Webpack解析到一个模块时，它会根据预定的规则，比如文件扩展名或者自定义的规则，来确定使用哪个加载器来处理该模块。
加载和转换模块：当Webpack解析到一个模块时，它会使用指定的加载器来加载该模块，并将其转换成浏览器可以理解的代码。加载器可以执行各种任务，比如将ES6代码转换为ES5，将SCSS文件转换为CSS等。
模块依赖的分析和打包：Webpack会根据模块之间的依赖关系，构建一个依赖图。通过这个依赖图，Webpack可以确定哪些模块需要被打包，并且确定它们的顺序。Webpack使用一种称为Chunk的机制，将相关的模块打包成一个或多个Chunk。
生成输出文件：最后，Webpack会将打包后的模块输出到指定的目录中。输出文件的名称和目录通常在Webpack的配置文件中指定。
总结一下，Webpack的打包流程包括配置、解析依赖、加载和转换模块、模块依赖的分析和打包，以及生成输出文件。这样，我们就可以将多个模块打包成一个或多个输出文件，以供浏览器使用。

999.开发中遇到的问题